栈溢出:StackOverflowError 方法递归没终止条件


堆内存溢出： outOfMemory
内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求（线程太多，内存不够创建新线程）
内存泄漏：指程序中动态分配内存给一些临时对象，但是对象不会被GC所回收，它始终占用内存,内存泄漏终将导致内存溢出

内存溢出原因
内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
代码中存在死循环或循环产生过多重复的对象实体；
使用的第三方软件中的BUG；
启动参数内存值设定的过小；

需要重点排查以下几点：
检查代码中是否有死循环或递归调用。
检查是否有大循环重复产生新对象实体。
检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。

优化：
调大堆内存大小，看看哪些对象生命周期太长
-XX:+HeapDumpOnOutOfMemoryError  让JVM在发生内存溢出时自动的生成堆内存快照
VisualJvm分析内存
找到内存溢出的具体代码
扩大堆内存或者优化对象生命周期

full gc触发条件
System.gc() 执行full gc
老年代空间不足
执行minor gc时判断当前老年代剩余空间大于新生代空间之和(eden+survivor*2中回收对象)则full gc

full gc太频繁
老年代满了导致full gc
原因是大多数对象经过几次major gc之后依然存活存入老年代，导致老年代数据频繁增加
解决方法：1、优化对象生命周期 2、调到survivor次数 3、增大老年代