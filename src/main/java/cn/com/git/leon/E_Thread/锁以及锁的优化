悲观锁（例如：synchronized）: 默认每次修改数据都有冲突
乐观锁（列入: reentrantLock,CAS,原子类）: 默认每次没有冲突，修改数据时才会检验

公平锁：指多个线程按照申请锁的顺序来获取锁。
非公平锁（synchronized，reentrantLock默认是，可以设置）：非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，

可重入锁(synchronized,reentrantLock):线程可以进入任何一个它已经拥有的锁所同步着的代码块

锁的优化：

锁的四种状态：无锁状态(01)、偏向锁(01,线程id)、轻量级锁(00)和重量级锁(10)
默认开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking禁用偏向锁
锁的状态保存在对象的头文件中

无锁->轻量->重量
在代码进入同步块的时候，如果同步对象锁状态为无锁状态 CAS设置为轻量级锁00,成功表示获得锁，失败则先判断是否当前线程拥有该锁，有则直接进入同步块
失败则CAS设置为重量级锁10，阻塞其它线程，自身通过自旋获取重量级锁，释放锁时唤醒其它线程

偏向锁
引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径
如果线程进入同步块锁的状态为01 则判断头文件中的线程id是否为当前线程 是则直接执行同步代码块
不是则CAS竞争锁失败则变为轻量级锁，并且被挂起

自旋锁与自适应自旋
自旋锁：利用while和cas设置锁好处不会阻塞引起上下文的切换（缺点：同步时间太长会导致cpu消耗高）
适应性自旋：如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。

锁粗化：
有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。
案例1：两段同步代码块中间的业务逻辑短-》两个锁合并
案例2：在for循环内枷锁-》锁在外面

锁消除
-server -XX:+DoEscapeAnalysis  逃逸分析
 -XX:+EliminateLocks    锁消除
 Java虚拟机在JIT编译是，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。
