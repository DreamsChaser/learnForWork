XA分布式事务协议
两阶段提交（2PC）和三阶段提交（3PC）
事务协调者和事务参与者
2PC
为事务协调者的节点会首先向所有的参与者节点发送Prepare请求
在接到Prepare请求之后，每一个参与者节点会各自执行与事务有关的数据更新，但不提交，返回“完成”
当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。
在XA分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出Commit请求。
接到Commit请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。
当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。
XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。


解决办法
1、补偿机制
针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：
Try
Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

2、kafka中间件保证
1、发送消息到消息服务器C，消息服务器C保存并记录状态New
2、事务开启，处理业务A，处理完毕，提交事务。发送消息到消息系统(幂等性message_id)
3、消息系统发送消息完毕，更新状态为发送
(需要另一个消息方 根据事务A和B的处理结果更新New状态的任务)
3、事务B收到消息 开启事务 处理完毕 提交事务 修改消息记录为已删除

另：
1、用户服务在接收到用户请求后开启事务, 在用户表创建一条用户记录, 并且在EventPublish表创建一条status为NEW的记录, payload记录的是事件内容, 提交事务.
2、用户服务中的定时器首先开启事务, 然后查询EventPublish是否有status为NEW的记录, 查询到记录之后, 拿到payload信息, 将消息发布到kafka中对应的topic.
 发送成功之后, 修改数据库中EventPublish的status为PUBLISHED, 提交事务.
3、代金券服务接收到kafka传来的用户创建事件(实际上是代金券服务主动拉取的消息, 先忽略消息队列的实现), 在EventProcess表创建一条status为NEW的记录, payload记录的是事件内容, 如果保存成功, 向kafka返回接收成功的消息.
4、代金券服务中的定时器首先开启事务, 然后查询EventProcess是否有status为NEW的记录, 查询到记录之后, 拿到payload信息, 交给事件回调处理器处理, 这里是直接创建代金券记录. 处理成功之后修改数据库中EventProcess的status为PROCESSED, 最后提交事务.



分布式事务从根本上应该从业务上规避这种情况的发生


系统A向消息中间件M预发送一条消息
M收到持久化记录消息为待发送
然后M返回ACK给系统A，此时MQ不会触发消息推送事件

系统A执行本地事务发送结果给消息中间件M
M根据结果删除或者更新为可发送
M发送'可发送'的消息给系统B

如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息。
如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,并重复这两步


